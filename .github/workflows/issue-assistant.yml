name: Secure Issue Assistant

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read
  models: read

concurrency:
  group: issue-${{ github.event.issue.number }}
  cancel-in-progress: false

env:
  MAX_INPUT_LENGTH: 10000
  MAX_BOT_RESPONSES: 4
  MIN_RESPONSE_INTERVAL_SECONDS: 120
  RATE_LIMIT_PER_USER_PER_HOUR: 12

jobs:
  validate-and-triage:
    runs-on: ubuntu-latest
    if: >-
      ${{
        github.event.issue.state == 'open' &&
        !github.event.issue.pull_request &&
        (github.event_name == 'issues' ||
        (github.event_name == 'issue_comment' &&
        github.event.comment.user.type != 'Bot'))
      }}

    outputs:
      should_respond: "${{ steps.conversation-state.outputs.should_respond == 'true' && steps.validation.outputs.validation_passed == 'true' }}"
      conversation_state: ${{ steps.conversation-state.outputs.state }}
      conversation_history: ${{ steps.conversation-state.outputs.history }}
      issue_type: ${{ steps.validation.outputs.issue_type }}
      wiki_context: ${{ steps.wiki.outputs.context }}

    steps:
      - name: Analyze Conversation State
        id: conversation-state
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const isComment = context.eventName === 'issue_comment';
            const commenter = isComment ? context.payload.comment.user.login : null;
            const issueAuthor = issue.user.login;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });

            const botComments = comments.filter(function(c) {
              return c.body && c.body.includes('<!-- msdo-issue-assistant');
            });

            const stateRegex = /<!-- msdo-issue-assistant state:(\w+)/;
            let currentState = 'initial';
            let lastBotCommentTime = null;

            if (botComments.length > 0) {
              const lastBot = botComments[botComments.length - 1];
              const match = lastBot.body.match(stateRegex);
              if (match) currentState = match[1];
              lastBotCommentTime = new Date(lastBot.created_at);
            }

            console.log('Current state: ' + currentState);
            console.log('Bot responses so far: ' + botComments.length);

            const maxResponses = parseInt(process.env.MAX_BOT_RESPONSES) || 4;
            if (botComments.length >= maxResponses) {
              console.log('Max responses reached - stopping');
              core.setOutput('should_respond', 'false');
              core.setOutput('state', 'max_responses');
              return;
            }

            if (['resolved', 'escalated'].includes(currentState)) {
              console.log('Terminal state - no more responses');
              core.setOutput('should_respond', 'false');
              core.setOutput('state', currentState);
              return;
            }

            if (isComment && commenter !== issueAuthor) {
              console.log('Comment not from issue author - skipping');
              core.setOutput('should_respond', 'false');
              core.setOutput('state', 'wrong_user');
              return;
            }

            if (lastBotCommentTime) {
              const cooldownMs = (parseInt(process.env.MIN_RESPONSE_INTERVAL_SECONDS) || 120) * 1000;
              const timeSinceLastBot = Date.now() - lastBotCommentTime.getTime();
              if (timeSinceLastBot < cooldownMs) {
                console.log('Cooldown active');
                core.setOutput('should_respond', 'false');
                core.setOutput('state', 'cooldown');
                return;
              }
            }

            if (isComment && botComments.length > 0) {
              const lastBotTime = new Date(botComments[botComments.length - 1].created_at);
              const authorCommentsSinceBot = comments.filter(function(c) {
                return c.user.login === issueAuthor &&
                  new Date(c.created_at) > lastBotTime &&
                  !c.body.includes('<!-- msdo-issue-assistant');
              });
              if (authorCommentsSinceBot.length === 0) {
                console.log('No new author content');
                core.setOutput('should_respond', 'false');
                core.setOutput('state', 'no_new_content');
                return;
              }
            }

            var sanitizeContent = function(content, maxLength) {
              maxLength = maxLength || 10000;
              if (content == null || content === '') return '';
              var str = String(content);
              var sanitized = str
                .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
                .replace(/\r\n/g, '\n')
                .replace(/\r/g, '\n')
                .replace(/[^\S\r\n]+/g, ' ')
                .replace(/\n{3,}/g, '\n\n')
                .trim();
              if (sanitized.length > maxLength) {
                sanitized = sanitized.substring(0, maxLength) + '... [truncated]';
              }
              return sanitized;
            };
            
            var history = [];
            var issueContent = '[Issue opened] ' + issue.title + '\n\n' + (issue.body || '(no description)');
            history.push({
              role: 'user',
              author: issueAuthor,
              content: sanitizeContent(issueContent),
              timestamp: issue.created_at
            });

            for (var i = 0; i < comments.length; i++) {
              var comment = comments[i];
              var isBot = comment.body.includes('<!-- msdo-issue-assistant');
              var isIssueAuthor = comment.user.login === issueAuthor;
              
              if (!isBot && !isIssueAuthor) continue;
              
              var content = comment.body;
              if (isBot) {
                content = content
                  .replace(/<!-- msdo-issue-assistant[^>]*-->/g, '')
                  .replace(/<details>[\s\S]*?<\/details>/g, '')
                  .trim();
              } else {
                content = sanitizeContent(content);
              }

              history.push({
                role: isBot ? 'assistant' : 'user',
                author: comment.user.login,
                content: content,
                timestamp: comment.created_at
              });
            }

            var nextState = 'gathering';
            if (botComments.length === 0) {
              nextState = 'initial';
            } else if (botComments.length >= maxResponses - 1) {
              nextState = 'final_attempt';
            }

            console.log('Next state: ' + nextState);

            var MAX_HISTORY_TURNS = 10;
            var trimmedHistory = history.slice(-MAX_HISTORY_TURNS);

            core.setOutput('should_respond', 'true');
            core.setOutput('state', nextState);
            core.setOutput('history', JSON.stringify(trimmedHistory));

      - name: Checkout repository
        if: steps.conversation-state.outputs.should_respond == 'true'
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/issue-assistant
            .github/wiki-context.md
          sparse-checkout-cone-mode: false

      - name: Load wiki context
        if: steps.conversation-state.outputs.should_respond == 'true'
        id: wiki
        shell: bash
        run: |
          if [ -f ".github/wiki-context.md" ]; then
            echo "Using cached wiki"
            WIKI_B64=$(base64 -w 0 < .github/wiki-context.md)
            echo "context=$WIKI_B64" >> $GITHUB_OUTPUT
            exit 0
          fi

          WIKI_URL="https://github.com/${{ github.repository }}.wiki.git"
          if git clone --depth 1 "$WIKI_URL" wiki-content 2>/dev/null; then
            echo "Wiki cloned"
            WIKI_FILE=$(mktemp)
            for page in Home FAQ Troubleshooting Configuration Tools; do
              if [ -f "wiki-content/${page}.md" ]; then
                echo -e "\n## ${page}\n" >> "$WIKI_FILE"
                head -c 4000 "wiki-content/${page}.md" >> "$WIKI_FILE"
              fi
            done
            WIKI_B64=$(base64 -w 0 < "$WIKI_FILE")
            echo "context=$WIKI_B64" >> $GITHUB_OUTPUT
            rm "$WIKI_FILE"
          else
            echo "No wiki available"
            echo "context=" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        if: steps.conversation-state.outputs.should_respond == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Security Validation
        if: steps.conversation-state.outputs.should_respond == 'true'
        id: validation
        uses: actions/github-script@v7
        env:
          INJECTION_PATTERNS: ${{ secrets.INJECTION_PATTERNS }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const isComment = context.eventName === 'issue_comment';
            const rawContent = isComment 
              ? context.payload.comment.body 
              : context.payload.issue.body || '';

            const securityPath = path.join(process.cwd(), '.github/issue-assistant/src/security.js');

            if (!fs.existsSync(securityPath)) {
              console.log('::warning::security.js not found');
              core.setOutput('validation_passed', 'true');
              core.setOutput('sanitized_content', rawContent.slice(0, parseInt(process.env.MAX_INPUT_LENGTH)));
              core.setOutput('issue_type', 'unknown');
              return;
            }

            const securityCode = fs.readFileSync(securityPath, 'utf8');
            const moduleExports = {};
            const moduleObj = { exports: moduleExports };
            const fn = new Function('module', 'exports', 'require', securityCode);
            fn(moduleObj, moduleExports, require);
            const security = moduleObj.exports;

            let injectionPatterns = null;
            if (process.env.INJECTION_PATTERNS) {
              try {
                injectionPatterns = JSON.parse(process.env.INJECTION_PATTERNS);
              } catch (e) {
                console.log('::warning::Could not parse INJECTION_PATTERNS');
              }
            }

            const result = await security.validateRequest({
              github,
              context,
              maxInputLength: parseInt(process.env.MAX_INPUT_LENGTH),
              rateLimitPerHour: parseInt(process.env.RATE_LIMIT_PER_USER_PER_HOUR),
              maxBotResponses: parseInt(process.env.MAX_BOT_RESPONSES),
              customInjectionPatterns: injectionPatterns
            });

            core.setOutput('validation_passed', result.shouldRespond ? 'true' : 'false');
            core.setOutput('sanitized_content', result.sanitizedContent || '');
            core.setOutput('issue_type', result.issueType || 'unknown');

  respond-with-ai:
    needs: validate-and-triage
    runs-on: ubuntu-latest
    if: ${{ needs.validate-and-triage.outputs.should_respond == 'true' }}

    steps:
      - name: Decode Wiki Context
        id: decode-wiki
        shell: bash
        run: |
          WIKI_B64="${{ needs.validate-and-triage.outputs.wiki_context }}"
          if [ -n "$WIKI_B64" ]; then
            echo "$WIKI_B64" | base64 -d > /tmp/wiki_context.txt
            echo "has_wiki=true" >> $GITHUB_OUTPUT
          else
            touch /tmp/wiki_context.txt
            echo "has_wiki=false" >> $GITHUB_OUTPUT
          fi

      - name: AI Response
        id: ai-analysis
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SYSTEM_PROMPT: ${{ secrets.ISSUE_ASSISTANT_SYSTEM_PROMPT }}
          STATE_PROMPTS: ${{ secrets.ISSUE_ASSISTANT_STATE_PROMPTS }}
          CANARY_TOKEN: ${{ secrets.CANARY_TOKEN }}
          ALLOWED_URLS: ${{ secrets.ALLOWED_URLS }}
          CONVERSATION_STATE: ${{ needs.validate-and-triage.outputs.conversation_state }}
          CONVERSATION_HISTORY: ${{ needs.validate-and-triage.outputs.conversation_history }}
          ISSUE_TYPE: ${{ needs.validate-and-triage.outputs.issue_type }}
          HAS_WIKI: ${{ steps.decode-wiki.outputs.has_wiki }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        with:
          script: |
            const fs = require('fs');
            
            const MIN_RESPONSE_LENGTH = 20;
            const MAX_RESPONSE_LENGTH = 1500;

            var wikiContext = '';
            if (process.env.HAS_WIKI === 'true') {
              try {
                wikiContext = fs.readFileSync('/tmp/wiki_context.txt', 'utf8');
              } catch (e) {}
            }

            var conversationState = process.env.CONVERSATION_STATE;
            var conversationHistory = JSON.parse(process.env.CONVERSATION_HISTORY || '[]');
            var repoOwner = process.env.REPO_OWNER;
            var repoName = process.env.REPO_NAME;
            var wikiUrl = 'https://github.com/' + repoOwner + '/' + repoName + '/wiki';

            var systemPrompt = process.env.SYSTEM_PROMPT || '';
            
            var statePrompts = {};
            if (process.env.STATE_PROMPTS) {
              try {
                statePrompts = JSON.parse(process.env.STATE_PROMPTS);
              } catch (e) {
                console.log('::warning::Could not parse STATE_PROMPTS');
              }
            }

            if (statePrompts[conversationState]) {
              systemPrompt += '\n\n' + statePrompts[conversationState];
            }

            var userPrompt = 'Issue Type: ' + process.env.ISSUE_TYPE + '\n';
            userPrompt += 'State: ' + conversationState + '\n\n';
            userPrompt += '--- CONVERSATION ---\n';
            
            for (var i = 0; i < conversationHistory.length; i++) {
              var turn = conversationHistory[i];
              var role = turn.role === 'assistant' ? 'BOT' : 'USER';
              var marker = (i === conversationHistory.length - 1) ? ' [LATEST]' : '';
              userPrompt += '[' + role + ']' + marker + ' ' + turn.content + '\n\n';
            }

            if (wikiContext) {
              userPrompt += '--- WIKI ---\n' + wikiContext + '\n\n';
            }

            userPrompt += '--- TASK ---\nRespond to the latest message. Wiki: ' + wikiUrl;

            var aiResponse = '';
            var outcome = 'gathering';

            try {
              var response = await fetch('https://models.github.ai/inference/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': 'Bearer ' + process.env.GITHUB_TOKEN,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  model: 'openai/gpt-4o-mini',
                  messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                  ],
                  max_tokens: 800,
                  temperature: 0.3
                })
              });

              if (!response.ok) {
                throw new Error('API returned ' + response.status);
              }

              var data = await response.json();
              aiResponse = data.choices && data.choices[0] && data.choices[0].message
                ? data.choices[0].message.content
                : '';

              var outcomeMatch = aiResponse.match(/\[OUTCOME:(\w+)\]/);
              if (outcomeMatch) {
                outcome = outcomeMatch[1];
                aiResponse = aiResponse.replace(/\s*\[OUTCOME:\w+\]\s*/g, '').trim();
              }

            } catch (error) {
              console.log('::warning::AI API failed: ' + error.message);
              core.setOutput('response', '');
              core.setOutput('is_valid', 'false');
              core.setOutput('outcome', 'error');
              return;
            }

            var trimmed = aiResponse ? aiResponse.trim() : '';
            if (!trimmed || trimmed.length < MIN_RESPONSE_LENGTH || trimmed.length > MAX_RESPONSE_LENGTH) {
              console.log('::warning::Response length invalid');
              core.setOutput('response', '');
              core.setOutput('is_valid', 'false');
              core.setOutput('outcome', 'error');
              return;
            }

            var isValid = true;
            var issues = [];

            var canaryToken = process.env.CANARY_TOKEN || '';
            if (canaryToken && aiResponse.includes(canaryToken)) {
              issues.push('Canary leaked');
              isValid = false;
            }

            var secretPatterns = [
              /ghp_[a-zA-Z0-9]{36}/,
              /github_pat_[a-zA-Z0-9_]{82}/,
              /gho_[a-zA-Z0-9]{36}/,
              /sk-[a-zA-Z0-9]{48}/,
              /sk-ant-[a-zA-Z0-9-]{90,}/,
              /AKIA[0-9A-Z]{16}/,
              /eyJ[a-zA-Z0-9_-]{20,}\.[a-zA-Z0-9_-]{20,}/,
              /-----BEGIN (RSA |EC )?PRIVATE KEY/
            ];

            for (var p = 0; p < secretPatterns.length; p++) {
              if (secretPatterns[p].test(aiResponse)) {
                issues.push('Secret pattern');
                isValid = false;
                break;
              }
            }

            var allowedDomains = [
              'github.com/microsoft/security-devops-action',
              'learn.microsoft.com',
              'docs.microsoft.com',
              'aka.ms'
            ];

            if (process.env.ALLOWED_URLS) {
              try {
                allowedDomains = JSON.parse(process.env.ALLOWED_URLS);
              } catch (e) {}
            }
            allowedDomains.push('github.com/' + repoOwner + '/' + repoName);

            var urlRegex = /https?:\/\/[^\s)>\]]+/gi;
            var foundUrls = aiResponse.match(urlRegex) || [];
            for (var u = 0; u < foundUrls.length; u++) {
              try {
                var parsedUrl = new URL(foundUrls[u]);
                var fullPath = parsedUrl.hostname + parsedUrl.pathname;
                var allowed = false;
                for (var d = 0; d < allowedDomains.length; d++) {
                  var domain = allowedDomains[d];
                  if (domain.includes('/')) {
                    if (fullPath.startsWith(domain) || fullPath.startsWith(domain.replace(/\/$/, ''))) {
                      allowed = true;
                      break;
                    }
                  } else if (parsedUrl.hostname === domain || parsedUrl.hostname.endsWith('.' + domain)) {
                    allowed = true;
                    break;
                  }
                }
                if (!allowed) {
                  issues.push('Unapproved URL');
                  isValid = false;
                }
              } catch (e) {
                issues.push('Invalid URL');
                isValid = false;
              }
            }

            core.setOutput('response', aiResponse);
            core.setOutput('is_valid', isValid.toString());
            core.setOutput('outcome', outcome);

      - name: Post Response
        if: ${{ steps.ai-analysis.outputs.is_valid == 'true' }}
        uses: actions/github-script@v7
        env:
          AI_RESPONSE: ${{ steps.ai-analysis.outputs.response }}
          OUTCOME: ${{ steps.ai-analysis.outputs.outcome }}
          FOOTER_TEMPLATES: ${{ secrets.ISSUE_ASSISTANT_FOOTERS }}
        with:
          script: |
            var response = process.env.AI_RESPONSE;
            var outcome = process.env.OUTCOME;
            var wikiUrl = 'https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/wiki';

            var stateMap = { 'resolved': 'resolved', 'escalated': 'escalated', 'gathering': 'gathering', 'error': 'gathering' };
            var state = stateMap[outcome] || 'gathering';

            var footers = {};
            if (process.env.FOOTER_TEMPLATES) {
              try {
                footers = JSON.parse(process.env.FOOTER_TEMPLATES);
              } catch (e) {}
            }

            var labelFailed = false;
            if (outcome === 'escalated') {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: ['needs-maintainer']
                });
              } catch (e) {
                labelFailed = true;
              }
            }

            var comment = '<!-- msdo-issue-assistant state:' + state + ' -->\n';
            comment += response + '\n\n---\n';
            
            var footer = footers[outcome] || footers['default'] || '';
            footer = footer.replace(/\{wikiUrl\}/g, wikiUrl);
            if (labelFailed && outcome === 'escalated') {
              footer += '\n\nNote: Could not add label automatically.';
            }
            comment += footer;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: Post Fallback
        if: ${{ steps.ai-analysis.outputs.is_valid != 'true' }}
        uses: actions/github-script@v7
        env:
          FALLBACK_TEMPLATE: ${{ secrets.ISSUE_ASSISTANT_FALLBACK }}
        with:
          script: |
            var wikiUrl = 'https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/wiki';
            var template = process.env.FALLBACK_TEMPLATE || 'To help investigate, please share:\n- MSDO version\n- OS and runner\n- Error logs\n- Workflow YAML';
            var comment = '<!-- msdo-issue-assistant state:gathering -->\n' + template.replace(/\{wikiUrl\}/g, wikiUrl);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
