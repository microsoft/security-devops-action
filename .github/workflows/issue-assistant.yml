name: Secure Issue Assistant

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read
  models: read

concurrency:
  group: issue-${{ github.event.issue.number }}
  cancel-in-progress: false

env:
  MAX_INPUT_LENGTH: 10000
  MAX_BOT_RESPONSES: 4
  MIN_RESPONSE_INTERVAL_SECONDS: 120
  RATE_LIMIT_PER_USER_PER_HOUR: 12

jobs:
  validate-and-triage:
    runs-on: ubuntu-latest
    if: >-
      ${{
        github.event.issue.state == 'open' &&
        !github.event.issue.pull_request &&
        (github.event_name == 'issues' ||
        (github.event_name == 'issue_comment' &&
        github.event.comment.user.type != 'Bot'))
      }}

    outputs:
      should_respond: ${{ (steps.conversation-state.outputs.should_respond == 'true' && steps.validation.outputs.validation_passed == 'true') ? 'true' : 'false' }}
      conversation_state: ${{ steps.conversation-state.outputs.state }}
      conversation_history: ${{ steps.conversation-state.outputs.history }}
      issue_type: ${{ steps.validation.outputs.issue_type }}
      wiki_context: ${{ steps.wiki.outputs.context }}

    steps:
      - name: Analyze Conversation State
        id: conversation-state
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const isComment = context.eventName === 'issue_comment';
            const commenter = isComment ? context.payload.comment.user.login : null;
            const issueAuthor = issue.user.login;

            // Get all comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });

            // Parse bot comments and their states
            const botComments = comments.filter(c => 
              c.body && c.body.includes('<!-- msdo-issue-assistant')
            );

            // Extract state from most recent bot comment.
            // Note: Only states that are actually written into bot comments can be
            // recovered via this regex (e.g., 'initial', 'gathering', 'final_attempt',
            // 'resolved', 'escalated', 'closed'). Other defined states such as
            // 'max_responses', 'wrong_user', and 'no_new_content' are internal/terminal
            // states used in non-response branches and are never persisted in comments.
            const stateRegex = /<!-- msdo-issue-assistant state:(\w+)/;
            let currentState = 'initial';
            let lastBotCommentTime = null;

            if (botComments.length > 0) {
              const lastBot = botComments[botComments.length - 1];
              const match = lastBot.body.match(stateRegex);
              if (match) currentState = match[1];
              lastBotCommentTime = new Date(lastBot.created_at);
            }

            console.log(`Current state: ${currentState}`);
            console.log(`Bot responses so far: ${botComments.length}`);

            // === SAFETY CHECKS ===

            // 1. Max responses limit
            const maxResponses = parseInt(process.env.MAX_BOT_RESPONSES) || 4;
            if (botComments.length >= maxResponses) {
              console.log(`Max responses (${maxResponses}) reached - stopping`);
              core.setOutput('should_respond', 'false');
              core.setOutput('state', 'max_responses');
              return;
            }

            // 2. Terminal states - don't respond further
            if (['resolved', 'escalated'].includes(currentState)) {
              console.log(`Terminal state "${currentState}" - no more responses`);
              core.setOutput('should_respond', 'false');
              core.setOutput('state', currentState);
              return;
            }

            // 3. For comments: only respond to issue author
            if (isComment && commenter !== issueAuthor) {
              console.log(`Comment from ${commenter}, but issue author is ${issueAuthor} - skipping`);
              core.setOutput('should_respond', 'false');
              core.setOutput('state', 'wrong_user');
              return;
            }

            // 4. Cooldown between responses (prevent rapid loops)
            if (lastBotCommentTime) {
              const cooldownMs = (parseInt(process.env.MIN_RESPONSE_INTERVAL_SECONDS) || 120) * 1000;
              const timeSinceLastBot = Date.now() - lastBotCommentTime.getTime();
              
              if (timeSinceLastBot < cooldownMs) {
                console.log(`Cooldown active (${Math.floor(timeSinceLastBot/1000)}s < ${cooldownMs/1000}s)`);
                core.setOutput('should_respond', 'false');
                core.setOutput('state', 'cooldown');
                return;
              }
            }

            // 5. For comments: require new content from author since last bot response
            if (isComment && botComments.length > 0) {
              const lastBotTime = new Date(botComments[botComments.length - 1].created_at);
              const authorCommentsSinceBot = comments.filter(c => 
                c.user.login === issueAuthor &&
                new Date(c.created_at) > lastBotTime &&
                !c.body.includes('<!-- msdo-issue-assistant')
              );

              if (authorCommentsSinceBot.length === 0) {
                console.log('No new author content since last bot response');
                core.setOutput('should_respond', 'false');
                core.setOutput('state', 'no_new_content');
                return;
              }
            }

            // === BUILD CONVERSATION HISTORY ===
            // Simple sanitization function to prevent injection attacks
            const sanitizeContent = (content, maxLength = 10000) => {
              if (!content) return '';
              let sanitized = content
                .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // Remove control characters
                .replace(/[^\S\r\n]+/g, ' ')                      // Normalize whitespace (except newlines)
                .replace(/\n{3,}/g, '\n\n')                       // Collapse excessive newlines
                .trim();
              if (sanitized.length > maxLength) {
                sanitized = sanitized.substring(0, maxLength) + '... [truncated]';
              }
              return sanitized;
            };
            
            const history = [];
            
            // Add issue body as first message (sanitize it)
            const issueContent = `[Issue opened] ${issue.title}\n\n${issue.body || '(no description)'}`;
            history.push({
              role: 'user',
              author: issueAuthor,
              content: sanitizeContent(issueContent),
              timestamp: issue.created_at
            });

            // Add comments from issue author and bot only (filter out other users)
            for (const comment of comments) {
              const isBot = comment.body.includes('<!-- msdo-issue-assistant');
              const isIssueAuthor = comment.user.login === issueAuthor;
              
              // Only include bot comments and comments from the issue author
              if (!isBot && !isIssueAuthor) {
                continue;
              }
              
              // Strip bot metadata from display
              let content = comment.body;
              if (isBot) {
                content = content
                  .replace(/<!-- msdo-issue-assistant[^-]*-->/g, '')
                  .replace(/<details>[\s\S]*?<\/details>/g, '')
                  .trim();
              }
              
              // Sanitize all user content before adding to history
              if (!isBot) {
                content = sanitizeContent(content);
              }

              history.push({
                role: isBot ? 'assistant' : 'user',
                author: comment.user.login,
                content: content,
                timestamp: comment.created_at
              });
            }

            // Determine next state based on conversation flow
            // Note: We can only reach this point if currentState is NOT a terminal state,
            // as terminal states are checked earlier (lines 98-103) and cause an early return.
            let nextState = currentState;
            
            if (botComments.length === 0) {
              nextState = 'initial';
            } else if (botComments.length >= maxResponses - 1) {
              nextState = 'final_attempt';
            } else if (currentState !== 'final_attempt') {
              // Keep 'final_attempt' if already set, otherwise use 'gathering'
              nextState = 'gathering';
            }

            console.log(`Will respond. Next state: ${nextState}`);
            console.log(`Conversation turns: ${history.length}`);

            core.setOutput('should_respond', 'true');
            core.setOutput('state', nextState);
            core.setOutput('history', JSON.stringify(history));

      - name: Checkout repository
        if: steps.conversation-state.outputs.should_respond == 'true'
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/issue-assistant
            .github/wiki-context.md
          sparse-checkout-cone-mode: false

      - name: Load cached wiki context
        if: steps.conversation-state.outputs.should_respond == 'true'
        id: wiki
        shell: bash
        run: |
          if [ -f ".github/wiki-context.md" ]; then
            echo "Using cached wiki"
            WIKI_B64=$(base64 -w 0 < .github/wiki-context.md)
            echo "context=$WIKI_B64" >> $GITHUB_OUTPUT
            echo "available=true" >> $GITHUB_OUTPUT
            echo "Size: $(wc -c < .github/wiki-context.md) bytes"
            exit 0
          fi

          WIKI_URL="https://github.com/${{ github.repository }}.wiki.git"

          if git clone --depth 1 "$WIKI_URL" wiki-content 2>/dev/null; then
            echo "Wiki cloned at runtime"
            WIKI_FILE=$(mktemp)

            for page in Home FAQ Troubleshooting Configuration Tools; do
              if [ -f "wiki-content/${page}.md" ]; then
                echo -e "\n## ${page}\n" >> "$WIKI_FILE"
                head -c 4000 "wiki-content/${page}.md" >> "$WIKI_FILE"
              fi
            done

            WIKI_B64=$(base64 -w 0 < "$WIKI_FILE")
            echo "context=$WIKI_B64" >> $GITHUB_OUTPUT
            echo "available=true" >> $GITHUB_OUTPUT
            rm "$WIKI_FILE"
          else
            echo "No wiki cache found and wiki not available"
            echo "context=" >> $GITHUB_OUTPUT
            echo "available=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        if: steps.conversation-state.outputs.should_respond == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Security Validation
        if: steps.conversation-state.outputs.should_respond == 'true'
        id: validation
        uses: actions/github-script@v7
        env:
          INJECTION_PATTERNS: ${{ secrets.INJECTION_PATTERNS }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // IMPORTANT: For issue_comment events, we validate ONLY the new comment content.
            // For issues events (new issue), we validate the issue body.
            // This ensures we don't re-validate the original issue body on subsequent comments.
            // If the original issue had validation issues but a new comment is clean, we allow it.
            // If a new comment has validation issues, we block it even if the issue body was clean.
            const isComment = context.eventName === 'issue_comment';
            const rawContent = isComment 
              ? context.payload.comment.body 
              : context.payload.issue.body || '';

            const securityPath = path.join(process.cwd(), '.github/issue-assistant/src/security.js');

            if (!fs.existsSync(securityPath)) {
              console.log('::warning::security.js not found');
              core.setOutput('validation_passed', 'true');
              core.setOutput('sanitized_content', rawContent.slice(0, parseInt(process.env.MAX_INPUT_LENGTH)));
              core.setOutput('issue_type', 'unknown');
              return;
            }

            const securityCode = fs.readFileSync(securityPath, 'utf8');
            const moduleExports = {};
            const moduleObj = { exports: moduleExports };
            const fn = new Function('module', 'exports', 'require', securityCode);
            fn(moduleObj, moduleExports, require);
            const security = moduleObj.exports;

            let injectionPatterns = null;
            if (process.env.INJECTION_PATTERNS) {
              try {
                injectionPatterns = JSON.parse(process.env.INJECTION_PATTERNS);
              } catch (e) {
                console.log('::warning::Could not parse INJECTION_PATTERNS');
              }
            }

            const result = await security.validateRequest({
              github,
              context,
              maxInputLength: parseInt(process.env.MAX_INPUT_LENGTH),
              rateLimitPerHour: parseInt(process.env.RATE_LIMIT_PER_USER_PER_HOUR),
              maxBotResponses: parseInt(process.env.MAX_BOT_RESPONSES),
              customInjectionPatterns: injectionPatterns
            });

            core.setOutput('validation_passed', result.shouldRespond ? 'true' : 'false');
            core.setOutput('sanitized_content', result.sanitizedContent || '');
            core.setOutput('issue_type', result.issueType || 'unknown');

            if (!result.shouldRespond) {
              const contentType = isComment ? 'comment' : 'issue body';
              console.log(`Validation failed for ${contentType}:`, result.errors);
            }

  respond-with-ai:
    needs: validate-and-triage
    runs-on: ubuntu-latest
    if: ${{ needs.validate-and-triage.outputs.should_respond == 'true' }}

    steps:
      - name: Decode Wiki Context
        id: decode-wiki
        shell: bash
        run: |
          WIKI_B64="${{ needs.validate-and-triage.outputs.wiki_context }}"
          if [ -n "$WIKI_B64" ]; then
            echo "$WIKI_B64" | base64 -d > /tmp/wiki_context.txt
            echo "has_wiki=true" >> $GITHUB_OUTPUT
          else
            touch /tmp/wiki_context.txt
            echo "has_wiki=false" >> $GITHUB_OUTPUT
          fi

      - name: Conversational AI Response
        id: ai-analysis
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SYSTEM_PROMPT: ${{ secrets.ISSUE_ASSISTANT_SYSTEM_PROMPT }}
          CANARY_TOKEN: ${{ secrets.CANARY_TOKEN }}
          ALLOWED_URLS: ${{ secrets.ALLOWED_URLS }}
          CONVERSATION_STATE: ${{ needs.validate-and-triage.outputs.conversation_state }}
          CONVERSATION_HISTORY: ${{ needs.validate-and-triage.outputs.conversation_history }}
          ISSUE_TYPE: ${{ needs.validate-and-triage.outputs.issue_type }}
          HAS_WIKI: ${{ steps.decode-wiki.outputs.has_wiki }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        with:
          script: |
            const fs = require('fs');
            
            // Response validation constants
            const MIN_AI_RESPONSE_LENGTH = 20;
            const MAX_AI_RESPONSE_LENGTH = 1000; // ~150 words (~750 chars) + 250 char buffer for markdown

            let wikiContext = '';
            if (process.env.HAS_WIKI === 'true') {
              try {
                wikiContext = fs.readFileSync('/tmp/wiki_context.txt', 'utf8');
                console.log('Wiki context loaded: ' + wikiContext.length + ' chars');
              } catch (e) {
                console.log('Could not read wiki context');
              }
            }

            const conversationState = process.env.CONVERSATION_STATE;
            const conversationHistory = JSON.parse(process.env.CONVERSATION_HISTORY || '[]');
            const repoOwner = process.env.REPO_OWNER;
            const repoName = process.env.REPO_NAME;
            const wikiUrl = `https://github.com/${repoOwner}/${repoName}/wiki`;

            // Build conversation-aware system prompt
            let systemPrompt = process.env.SYSTEM_PROMPT || '';
            
            const stateInstructions = {
              initial: `This is a NEW issue. Analyze it and either:
1. If wiki has the answer ‚Üí provide the solution directly
2. If missing critical info ‚Üí ask specific questions (max 3-4 bullets)
3. If clearly needs maintainer ‚Üí acknowledge and escalate`,
              
              gathering: `This is an ONGOING conversation. The user has provided more info.
1. Check if their response + wiki now allows you to answer
2. If yes ‚Üí provide the solution, mark as RESOLVED
3. If still missing info ‚Üí ask ONE focused follow-up
4. If stuck or out of scope ‚Üí escalate to maintainer`,
              
              final_attempt: `This is your FINAL response opportunity.
1. Summarize what you know and any partial solutions from wiki
2. Clearly state what a maintainer needs to investigate
3. Do NOT ask more questions - either answer or escalate`
            };

            // Build system prompt with state instructions
            // If SYSTEM_PROMPT exists, append state marker with spacing
            // If not, start directly with state marker (no leading whitespace)
            if (systemPrompt) {
              systemPrompt += `\n\n--- CONVERSATION STATE: ${conversationState.toUpperCase()} ---\n`;
            } else {
              systemPrompt = `--- CONVERSATION STATE: ${conversationState.toUpperCase()} ---\n`;
            }
            systemPrompt += stateInstructions[conversationState] || stateInstructions.gathering;
            
            systemPrompt += `\n\n--- RESPONSE FORMAT ---
End your response with exactly one of these outcome tags (hidden from user):
- [OUTCOME:resolved] - You answered their question from wiki/knowledge
- [OUTCOME:gathering] - You asked for more information  
- [OUTCOME:escalated] - Needs maintainer, you've done what you can

Keep responses concise (50-150 words). No signatures.`;

            // Build the conversation prompt
            let userPrompt = `ISSUE TRIAGE CONVERSATION\n\n`;
            userPrompt += `Issue Type: ${process.env.ISSUE_TYPE}\n`;
            userPrompt += `Conversation State: ${conversationState}\n`;
            userPrompt += `Turns so far: ${conversationHistory.length}\n\n`;

            userPrompt += `--- CONVERSATION HISTORY ---\n`;
            for (let i = 0; i < conversationHistory.length; i++) {
              const turn = conversationHistory[i];
              const role = turn.role === 'assistant' ? 'BOT' : 'USER';
              const isLatest = (i === conversationHistory.length - 1);
              const marker = isLatest ? ' ‚¨Ö RESPOND TO THIS' : '';
              userPrompt += `[${role}]${marker} ${turn.content}\n\n`;
            }

            if (wikiContext) {
              userPrompt += `--- WIKI KNOWLEDGE BASE ---\n${wikiContext}\n\n`;
            }

            userPrompt += `--- YOUR TASK ---\n`;
            userPrompt += `If wiki answers their question, provide the solution. Otherwise, ask for missing info or escalate to maintainers.\n`;
            userPrompt += `Wiki URL: ${wikiUrl}\n`;

            let aiResponse = '';
            let outcome = 'gathering';

            try {
              console.log('Calling GitHub Models API...');
              console.log(`State: ${conversationState}, History turns: ${conversationHistory.length}`);

              const response = await fetch('https://models.github.ai/inference/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  model: 'openai/gpt-4o-mini',
                  messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                  ],
                  max_tokens: 800,
                  temperature: 0.3
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API returned ${response.status}: ${errorText}`);
              }

              const data = await response.json();
              aiResponse = data.choices?.[0]?.message?.content || '';

              // Extract outcome tag
              const outcomeMatch = aiResponse.match(/\[OUTCOME:(\w+)\]/);
              const allOutcomeTags = aiResponse.match(/\[OUTCOME:[^\]]+\]/g) || [];

              if (outcomeMatch) {
                if (allOutcomeTags.length > 1) {
                  console.log(`::warning::Multiple outcome tags found in AI response; using first valid tag. Tags: ${allOutcomeTags.join(', ')}`);
                }
                outcome = outcomeMatch[1];
                aiResponse = aiResponse.replace(/\s*\[OUTCOME:\w+\]\s*$/, '').trim();
              } else {
                if (allOutcomeTags.length > 0) {
                  console.log(`::warning::Outcome-like tags present but none matched expected format "[OUTCOME:state]"; defaulting outcome to "gathering". Tags: ${allOutcomeTags.join(', ')}`);
                } else {
                  console.log('::warning::No [OUTCOME:...] tag found in AI response; defaulting outcome to "gathering".');
                }
              }

              console.log(`AI response: ${aiResponse.length} chars, outcome: ${outcome}`);

            } catch (error) {
              console.log(`::warning::AI API failed: ${error.message}`);
              core.setOutput('response', '');
              core.setOutput('is_valid', 'false');
              core.setOutput('outcome', 'error');
              return;
            }

            // Trim response once for validation
            const trimmedResponse = aiResponse ? aiResponse.trim() : '';

            if (!trimmedResponse || trimmedResponse.length < MIN_AI_RESPONSE_LENGTH) {
              console.log(`::warning::AI response too short (${trimmedResponse.length} chars, min ${MIN_AI_RESPONSE_LENGTH})`);
              core.setOutput('response', '');
              core.setOutput('is_valid', 'false');
              core.setOutput('outcome', 'error');
              return;
            }

            // Check maximum length (50-150 words guidance ‚âà 1000 chars with formatting)
            if (trimmedResponse.length > MAX_AI_RESPONSE_LENGTH) {
              console.log(`::warning::AI response too long (${trimmedResponse.length} chars, max ${MAX_AI_RESPONSE_LENGTH})`);
              core.setOutput('response', '');
              core.setOutput('is_valid', 'false');
              core.setOutput('outcome', 'error');
              return;
            }

            // === RESPONSE VALIDATION ===
            let isValid = true;
            const issues = [];

            // Canary token check
            const canaryToken = process.env.CANARY_TOKEN || '';
            if (canaryToken && aiResponse.includes(canaryToken)) {
              issues.push('Canary token leaked');
              isValid = false;
            }

            // Secret pattern detection
            const secretPatterns = [
              /ghp_[a-zA-Z0-9]{36}/,
              /github_pat_[a-zA-Z0-9_]{82}/,
              /gho_[a-zA-Z0-9]{36}/,
              /sk-[a-zA-Z0-9]{48}/,
              /sk-ant-[a-zA-Z0-9-]{90,}/,
              /AKIA[0-9A-Z]{16}/,
              /eyJ[a-zA-Z0-9_-]{20,}\.[a-zA-Z0-9_-]{20,}/,
              /['"][a-zA-Z0-9]{32,}['"]/,
              /-----BEGIN (RSA |EC )?PRIVATE KEY/,
            ];

            for (const pattern of secretPatterns) {
              if (pattern.test(aiResponse)) {
                issues.push('Secret pattern detected');
                isValid = false;
                break;
              }
            }

            // URL allowlist
            let allowedDomains = [
              'github.com/microsoft/security-devops-action',
              'learn.microsoft.com',
              'docs.microsoft.com',
              'aka.ms'
            ];

            if (process.env.ALLOWED_URLS) {
              try {
                allowedDomains = JSON.parse(process.env.ALLOWED_URLS);
              } catch (e) {}
            }
            allowedDomains.push(`github.com/${repoOwner}/${repoName}`);

            const urlRegex = /https?:\/\/[^\s)>\]]+/gi;
            const foundUrls = aiResponse.match(urlRegex) || [];
            for (const urlStr of foundUrls) {
              try {
                const parsedUrl = new URL(urlStr);
                const fullPath = parsedUrl.hostname + parsedUrl.pathname;
                
                const isAllowed = allowedDomains.some(domain => {
                  if (domain.includes('/')) {
                    return fullPath.startsWith(domain) || fullPath.startsWith(domain.replace(/\/$/, ''));
                  }
                  return parsedUrl.hostname === domain || parsedUrl.hostname.endsWith('.' + domain);
                });
                
                if (!isAllowed) {
                  issues.push(`Unapproved URL: ${urlStr}`);
                  isValid = false;
                }
              } catch (e) {
                issues.push(`Invalid URL: ${urlStr}`);
                isValid = false;
              }
            }

            core.setOutput('response', aiResponse);
            core.setOutput('is_valid', isValid.toString());
            core.setOutput('outcome', outcome);
            core.setOutput('issues', JSON.stringify(issues));

            if (!isValid) {
              console.log('Validation failed:', issues);
            }

      - name: Post Response
        if: ${{ steps.ai-analysis.outputs.is_valid == 'true' }}
        uses: actions/github-script@v7
        env:
          AI_RESPONSE: ${{ steps.ai-analysis.outputs.response }}
          OUTCOME: ${{ steps.ai-analysis.outputs.outcome }}
        with:
          script: |
            const response = process.env.AI_RESPONSE;
            const outcome = process.env.OUTCOME;
            const wikiUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/wiki`;

            // Map outcome to stored state
            const stateMap = {
              'resolved': 'resolved',
              'escalated': 'escalated', 
              'gathering': 'gathering',
              'error': 'gathering'
            };
            const state = stateMap[outcome] || 'gathering';

            // Try to add labels before posting comment
            let labelAdditionFailed = false;
            const labelsToAdd = [];
            if (outcome === 'escalated') {
              labelsToAdd.push('needs-maintainer');
            }
            if (labelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labelsToAdd
                });
                console.log('Successfully added labels:', labelsToAdd.join(', '));
              } catch (e) {
                console.log('Could not add labels:', e.message);
                labelAdditionFailed = true;
              }
            }

            // Build comment with hidden state marker
            let comment = `<!-- msdo-issue-assistant state:${state} -->\n`;
            comment += response + '\n\n';
            comment += '---\n';
            
            // Add contextual footer based on outcome
            if (outcome === 'resolved') {
              comment += `<details><summary>‚úÖ Issue assisted</summary>\n\n`;
              comment += `If this solved your issue, you can close it. `;
              comment += `Otherwise, reply and a maintainer will follow up.\n`;
            } else if (outcome === 'escalated') {
              comment += `<details><summary>üè∑Ô∏è Escalated to maintainers</summary>\n\n`;
              comment += `A maintainer will review this issue. `;
              comment += `No further bot responses will be sent.\n`;
              if (labelAdditionFailed) {
                comment += `\n‚ö†Ô∏è **Note:** Unable to automatically add the \`needs-maintainer\` label. A maintainer will need to add this label manually to ensure proper triage.\n`;
              }
            } else {
              comment += `<details><summary>üí¨ Gathering info</summary>\n\n`;
              comment += `Reply with the requested information and I'll try to help further.\n`;
            }
            
            comment += `[Wiki](${wikiUrl}) ¬∑ [FAQ](${wikiUrl}/FAQ)\n`;
            comment += `</details>`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

            console.log(`Posted response with outcome: ${outcome}, state: ${state}`);

      - name: Post Fallback Comment
        if: ${{ steps.ai-analysis.outputs.is_valid != 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const wikiUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/wiki`;

            const comment = `<!-- msdo-issue-assistant state:gathering -->\n` +
              `To help investigate, please share:\n` +
              `- MSDO version\n` +
              `- OS and runner type\n` +
              `- Error message/logs\n` +
              `- Workflow YAML\n\n` +
              `[FAQ](${wikiUrl}/FAQ) ¬∑ [Troubleshooting](${wikiUrl}/Troubleshooting)`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

            console.log('Fallback comment posted');
